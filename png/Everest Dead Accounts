def match_on_date_and_name(left, right, right_cols_keep,
                           left_date_col='inception_date',
                           right_date_col='inception_date',
                           tol_days=TOL_DAYS, threshold=THRESHOLD):
    # Normaliza headers para evitar problemas de mayúsculas/espacios
    left  = left.rename(columns={c: c.strip() for c in left.columns})
    right = right.rename(columns={c: c.strip() for c in right.columns})

    # Si los nombres no están en minúsculas, crea alias en minúsculas
    left.columns  = [c.lower() for c in left.columns]
    right.columns = [c.lower() for c in right.columns]
    right_cols_keep = [c.strip().lower() for c in right_cols_keep]

    left_date_col  = left_date_col.lower()
    right_date_col = right_date_col.lower()

    # Asegura que existen y que son datetime
    if right_date_col not in right.columns:
        raise KeyError(f"'{right_date_col}' no está en right.columns: {list(right.columns)}")
    if left_date_col not in left.columns:
        raise KeyError(f"'{left_date_col}' no está en left.columns: {list(left.columns)}")

    left[left_date_col]  = pd.to_datetime(left[left_date_col],  errors='coerce', dayfirst=DAYFIRST)
    right[right_date_col] = pd.to_datetime(right[right_date_col], errors='coerce', dayfirst=DAYFIRST)

    # Índice por fecha en right
    right_idx = right.set_index(right_date_col)

    rows = []
    for _, r in left.iterrows():
        d = r[left_date_col]
        if pd.isna(d):
            rows.append({**r.to_dict(), 'match_idx': None, 'match_score': 0})
            continue

        if tol_days > 0:
            mask = (right_idx.index >= d - pd.Timedelta(days=tol_days)) & \
                   (right_idx.index <= d + pd.Timedelta(days=tol_days))
            candidates = right_idx.loc[mask]
        else:
            candidates = right_idx.loc[right_idx.index == d]

        if candidates.empty:
            rows.append({**r.to_dict(), 'match_idx': None, 'match_score': 0})
            continue

        score, idx = fuzzy_best(r['insured_clean'], candidates['insured_clean'])
        if idx is None or score < threshold:
            rows.append({**r.to_dict(), 'match_idx': None, 'match_score': score})
            continue

        match_row = candidates.loc[idx]
        payload = match_row[right_cols_keep].to_dict()
        rows.append({**r.to_dict(), 'match_idx': idx, 'match_score': score, **payload})
    return pd.DataFrame(rows)
