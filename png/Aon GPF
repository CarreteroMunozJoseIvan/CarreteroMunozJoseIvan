import re
from datetime import datetime
import pandas as pd

# ========= UTILIDADES BÁSICAS =========

def _to_number(num_str: str | None):
    if num_str is None:
        return None
    s = num_str.replace(",", "").strip()
    try:
        return float(s)
    except ValueError:
        return None


def _parse_date_human(date_str: str | None):
    """
    Convierte '1st August 2025' -> '08/01/2025'
    """
    if not date_str:
        return None
    # quitar sufijos th / st / nd / rd
    date_str = re.sub(r"(\d+)(st|nd|rd|th)", r"\1", date_str.strip(), flags=re.I)
    for fmt in ("%d %B %Y", "%d %b %Y"):
        try:
            dt = datetime.strptime(date_str, fmt)
            return dt.strftime("%m/%d/%Y")
        except ValueError:
            continue
    return None


EEA_COUNTRIES = {
    "austria", "belgium", "bulgaria", "croatia", "cyprus", "czech republic",
    "denmark", "estonia", "finland", "france", "germany", "greece", "hungary",
    "ireland", "italy", "latvia", "liechtenstein", "lithuania", "luxembourg",
    "malta", "netherlands", "norway", "poland", "portugal", "romania",
    "slovakia", "slovenia", "spain", "sweden", "iceland"
}

def country_to_region(country: str | None) -> str | None:
    if not country:
        return None
    c = country.lower()
    for eea in EEA_COUNTRIES:
        if eea in c:
            return "EEA"
    return "ROW"


# ========= EXTRACTORES =========

def parse_account_name(text: str):
    """Account Name = ORIGINAL INSURED / Name: ..."""
    t = re.sub(r"[^\S\r\n]+", " ", text)

    m = re.search(r"ORIGINAL\s+INSURED.*?Name:\s*(.+)", t, flags=re.I | re.S)
    if m:
        after = m.group(1).strip()
        first_line = after.splitlines()[0].strip(" :-;")
        if first_line:
            return first_line

    for pat in [r"\bInsured\s*:\s*(.+)", r"\bAssured\s*:\s*(.+)"]:
        m = re.search(pat, t, flags=re.I)
        if m:
            return m.group(1).splitlines()[0].strip(" :-;")

    return None


def parse_unique_market_ref(text: str):
    m = re.search(r"UNIQUE\s+MARKET\s+REFERENCE\s*([\s:]*)([A-Z0-9/.-]+)", text, flags=re.I)
    if m:
        return m.group(2).strip()
    m = re.search(r"UNIQUE\s+MARKET\s+REFERENCE.*?\n([A-Z0-9/.-]+)", text, flags=re.I)
    if m:
        return m.group(1).strip()
    return None


def parse_policy_period(text: str):
    """Devuelve (inception_str, expiry_str) en formato mm/dd/yyyy."""
    m = re.search(
        r"PERIOD.*?From:\s*([^\n]+?)\n.*?To:\s*([^\n]+?)\n",
        text, flags=re.I | re.S
    )
    if not m:
        return None, None

    raw_from = m.group(1).strip()
    raw_to = m.group(2).strip()

    m_from = re.search(r"(\d{1,2}\w{0,2}\s+[A-Za-z]+\s+\d{4})", raw_from)
    m_to = re.search(r"(\d{1,2}\w{0,2}\s+[A-Za-z]+\s+\d{4})", raw_to)

    inc = _parse_date_human(m_from.group(1)) if m_from else None
    exp = _parse_date_human(m_to.group(1)) if m_to else None
    return inc, exp


def parse_country_from_address(text: str):
    """
    Mira la sección Address: y devuelve la última línea no vacía (país).
    """
    lines = text.splitlines()
    for i, line in enumerate(lines):
        if re.search(r"Address\s*:", line, flags=re.I):
            addr_lines = []
            for l in lines[i+1:]:
                if not l.strip():
                    break
                addr_lines.append(l.strip())
            if addr_lines:
                return addr_lines[-1]
    return None


def parse_layer_block(text: str):
    """
    Devuelve: (layer_str, contract_currency, layer_type, limit, attachment)
    layer_type ∈ {'Primary','XOL','Difference Between', None}
    """
    # XOL clásico: SUM (RE)INSURED ... In excess of ...
    pat_xol = re.compile(
        r"SUM\s*\(?RE\)?INSURED.*?"
        r"([A-Z]{3})\s*([\d,]+(?:\.\d+)?)"
        r".*?In\s+excess\s+of\s+"
        r"([A-Z]{3})?\s*([\d,]+(?:\.\d+)?)",
        flags=re.I | re.S
    )
    m = pat_xol.search(text)
    if m:
        c1, s1, c2, s2 = m.groups()
        limit = _to_number(s1)
        attachment = _to_number(s2)
        c2 = c2 or c1
        layer_str = f"{c1} {limit:,.0f} xs {c2} {attachment:,.0f}"
        return layer_str, c1, "XOL", limit, attachment

    # Primary explícito
    m = re.search(
        r"\bPrimary\b\s+([A-Z]{3})\s*([\d,]+(?:\.\d+)?)",
        text, flags=re.I
    )
    if m:
        cur, s = m.groups()
        limit = _to_number(s)
        layer_str = f"Primary {cur} {limit:,.0f}"
        return layer_str, cur, "Primary", limit, 0.0

    # SUM REINSURED sin 'excess'
    m = re.search(
        r"SUM\s*\(?RE\)?INSURED.*?([A-Z]{3})\s*([\d,]+(?:\.\d+)?)(?!.*In\s+excess)",
        text, flags=re.I | re.S
    )
    if m:
        cur, s = m.groups()
        limit = _to_number(s)
        layer_str = f"Primary {cur} {limit:,.0f}"
        return layer_str, cur, "Primary", limit, 0.0

    # Genérico 'USD 300m xs USD 100m'
    m = re.search(
        r"([A-Z]{3})\s*([\d,]+(?:\.\d+)?)(?:m|M)?\s*(?:x|xs)\s*([A-Z]{3})?\s*([\d,]+(?:\.\d+)?)(?:m|M)?",
        text, flags=re.I
    )
    if m:
        c1, s1, c2, s2 = m.groups()
        c2 = c2 or c1
        limit = _to_number(s1)
        attachment = _to_number(s2)
        layer_str = f"{c1} {limit:,.0f} xs {c2} {attachment:,.0f}"
        return layer_str, c1, "XOL", limit, attachment

    # Solo límite gordo tipo EUR 20,000,000
    m = re.search(r"\b([A-Z]{3})\s*([\d,]{6,})\b", text)
    if m:
        cur, s = m.groups()
        limit = _to_number(s)
        layer_str = f"Primary {cur} {limit:,.0f}"
        return layer_str, cur, "Primary", limit, 0.0

    return None, None, None, None, None


def parse_gross_premium(text: str):
    """
    Devuelve (currency, amount) del Gross Premium 100%.
    """
    m = re.search(
        r"Gross\s+Premium\s*:\s*([A-Z]{3})\s*([\d,]+(?:\.\d+)?)",
        text, flags=re.I
    )
    if m:
        cur, s = m.groups()
        return cur, _to_number(s)
    return None, None


def parse_tiv_total(text: str):
    """
    Busca el TOTAL de 'Total Insured Values'.
    Devuelve (currency, amount) del TOTAL.
    """
    m = re.search(
        r"Total\s+Insured\s+Values.*?([A-Z]{3})\s*([\d,]+(?:\.\d+)?)\s*TOTAL",
        text, flags=re.I | re.S
    )
    if m:
        cur, s = m.groups()
        return cur, _to_number(s)

    m = re.search(r"([A-Z]{3})\s*([\d,]+(?:\.\d+)?)\s*\n\s*TOTAL", text, flags=re.I)
    if m:
        cur, s = m.groups()
        return cur, _to_number(s)

    return None, None


def parse_loss_history(text: str):
    m = re.search(r"Loss\s+History\s*[-:]*\s*(.+)", text, flags=re.I)
    if m:
        return m.group(1).strip()
    return None


def parse_everest_share(text: str):
    """
    Busca el bloque de Everest (EVE) y devuelve el % 'Signed'
    como número (ej: 0.4206). Solo para EVE.
    """
    lines = text.splitlines()

    for i, line in enumerate(lines):
        if re.search(r"\bEVE\b", line):
            window = lines[i:i+12]  # miramos unas cuantas líneas abajo

            percent_indices = [j for j, l in enumerate(window) if "%" in l]

            for j in percent_indices:
                pct_line = window[j]
                prev_line = window[j-1] if j-1 >= 0 else ""
                next_line = window[j+1] if j+1 < len(window) else ""

                if ("signed" in pct_line.lower()
                        or "signed" in prev_line.lower()
                        or "signed" in next_line.lower()):
                    m = re.search(r"(\d+(?:\.\d+)?)\s*%", pct_line)
                    if m:
                        return float(m.group(1))
            break

    return None


# ========= FUNCIÓN PRINCIPAL PARA 1 SLIP (a partir de TEXTO) =========

def slip_text_to_dataframe(text: str, source_file: str = "") -> pd.DataFrame:
    account_name = parse_account_name(text)
    broker_ref = parse_unique_market_ref(text)
    inception, expiry = parse_policy_period(text)

    country = parse_country_from_address(text)
    region = country_to_region(country) if country else None

    layer_str, contract_currency, layer_type, limit, attachment = parse_layer_block(text)

    prem_cur, premium = parse_gross_premium(text)
    tiv_cur, tiv_total = parse_tiv_total(text)
    loss_history = parse_loss_history(text)
    everest_share = parse_everest_share(text)

    row = {
        "AccountName": account_name,
        "Layer": layer_str,
        "BrokerRef": broker_ref,
        "Inception": inception,
        "Expiry": expiry,
        "Country": country,
        "Region": region,
        "ContractCurrency": contract_currency,
        "Primary_XOL_or_Diff": layer_type,
        "Limit": limit,
        "Attachment": attachment,
        "Premium": premium,
        "PremiumCurrency": prem_cur,
        "TIV": tiv_total,
        "TIVCurrency": tiv_cur,
        "LossHistory": loss_history,
        "EverestShare": everest_share,
        "SourceFile": source_file,
    }

    return pd.DataFrame([row])

