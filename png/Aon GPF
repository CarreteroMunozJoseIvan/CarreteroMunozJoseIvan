def parse_account_name(text: str):
    """
    Account Name: buscamos la sección 'ORIGINAL INSURED' y cogemos la línea
    después de 'Name:' (primera no vacía).
    """
    lines = text.splitlines()

    # 1) Método principal: ORIGINAL INSURED + Name:
    for i, line in enumerate(lines):
        if re.search(r"ORIGINAL\s+INSURED", line, flags=re.I):
            # buscamos 'Name:' en las siguientes líneas
            for j in range(i + 1, min(i + 15, len(lines))):
                if re.search(r"^Name\s*:", lines[j], flags=re.I):
                    # la(s) siguiente(s) línea(s) no vacías contendrán el nombre
                    for k in range(j + 1, min(j + 6, len(lines))):
                        cand = lines[k].strip(" :-;")
                        if cand:
                            return cand
                    break
            # si no encontramos Name:, salimos de este bloque
            break

    # 2) Fallback: versión antigua basada en regex (por si otro slip viene distinto)
    t = re.sub(r"[^\S\r\n]+", " ", text)

    m = re.search(r"ORIGINAL\s+INSURED.*?Name:\s*(.+)", t, flags=re.I | re.S)
    if m:
        after = m.group(1).strip()
        for line in after.splitlines():
            cand = line.strip(" :-;")
            if cand:
                return cand

    for pat in [r"\bInsured\s*:\s*(.+)", r"\bAssured\s*:\s*(.+)"]:
        m = re.search(pat, t, flags=re.I)
        if m:
            return m.group(1).splitlines()[0].strip(" :-;")

    return None



def parse_country_from_address(text: str):
    """
    Mira la sección Address: y devuelve la línea del país.
    En tu ejemplo:
        Address:
        The Firs, 2nd Floor
        32 A Craddock Av
        Rosebank
        Republic of South Africa   ← queremos esta
        2194                       ← código postal (lo ignoramos)
    """
    lines = text.splitlines()
    for i, line in enumerate(lines):
        if re.search(r"Address\s*:", line, flags=re.I):
            addr_lines = []
            for l in lines[i+1:]:
                if not l.strip():
                    break
                addr_lines.append(l.strip())

            if not addr_lines:
                return None

            # primero intentamos la última línea que tenga letras
            for cand in reversed(addr_lines):
                if re.search(r"[A-Za-z]", cand):
                    return cand

            # si no encontramos letras (raro), devolvemos la última
            return addr_lines[-1]

    return None



def parse_loss_history(text: str):
    """
    Devuelve la ÚLTIMA 'Loss History ...' del slip, incluyendo la línea siguiente
    si no está vacía.

    Ejemplo objetivo:
        Loss History - No losses above deductible.
        Full loss history provided in 'Multi Choice_Consolidated Claims_2025.xlsx'
    """
    lines = text.splitlines()
    last_idx = None

    for i, line in enumerate(lines):
        if re.search(r"Loss\s+History", line, flags=re.I):
            last_idx = i  # nos quedamos con la última que veamos

    if last_idx is None:
        return None

    base_line = lines[last_idx]
    # quitar el prefijo 'Loss History -' o 'Loss History:'
    main_part = re.sub(
        r".*Loss\s+History\s*[-:]*\s*",
        "",
        base_line,
        flags=re.I
    ).strip()

    # mirar la línea siguiente por si completa la frase
    extra = ""
    if last_idx + 1 < len(lines):
        next_line = lines[last_idx + 1].strip()
        if next_line:
            extra = next_line

    if extra:
        return f"{main_part} {extra}".strip()
    else:
        return main_part or None

