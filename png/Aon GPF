from pathlib import Path
import re

# --- Limpieza básica del texto ---
def _clean_text(s: str) -> str:
    if not s:
        return ""
    # Une palabras cortadas al final de línea: "insuran-\nce" -> "insurance"
    s = re.sub(r"(\w)-\n(\w)", r"\1\2", s)
    # Normaliza saltos/espacios
    s = s.replace("\r", "")
    s = re.sub(r"[ \t]+", " ", s)
    s = re.sub(r"\n{3,}", "\n\n", s)  # no más de 2 saltos seguidos
    # Corrige ligaduras comunes (si aparecen)
    s = s.replace("ﬁ", "fi").replace("ﬂ", "fl")
    return s.strip()

# --- 1) Intento con PyMuPDF (fitz) ---
def _extract_with_pymupdf(pdf_path: Path) -> str:
    try:
        import fitz  # PyMuPDF
        text_parts = []
        with fitz.open(pdf_path) as doc:
            for page in doc:
                # TextPage (layout=True) mejora el orden de lectura
                text_parts.append(page.get_text("text"))
        return _clean_text("\n".join(text_parts))
    except Exception:
        return ""

# --- 2) Respaldo con pdfplumber (mejor en tablas/columnas) ---
def _extract_with_pdfplumber(pdf_path: Path, grab_tables: bool = True) -> str:
    try:
        import pdfplumber
        text_parts = []
        with pdfplumber.open(pdf_path) as pdf:
            for page in pdf.pages:
                t = page.extract_text() or ""
                if grab_tables:
                    try:
                        tables = page.extract_tables()
                        for tbl in tables or []:
                            # convierte la tabla a texto tipo CSV simple
                            lines = [", ".join([c or "" for c in row]) for row in tbl]
                            if lines:
                                t += "\n" + "\n".join(lines)
                    except Exception:
                        pass
                text_parts.append(t)
        return _clean_text("\n".join(text_parts))
    except Exception:
        return ""

# --- 3) (Opcional) OCR para PDFs escaneados ---
def _extract_with_ocr(pdf_path: Path, dpi: int = 300) -> str:
    try:
        from pdf2image import convert_from_path
        import pytesseract
        pages = convert_from_path(str(pdf_path), dpi=dpi)
        ocr_text = []
        for img in pages:
            ocr_text.append(pytesseract.image_to_string(img))
        return _clean_text("\n".join(ocr_text))
    except Exception:
        return ""

def extract_text_pdf_robust(pdf_path: Path, use_ocr_if_needed: bool = False) -> str:
    """
    Lee el PDF y devuelve texto lo más completo posible.
    Estrategia:
      1) PyMuPDF
      2) pdfplumber
      3) (opcional) OCR si el texto es muy corto
    """
    # 1
    txt = _extract_with_pymupdf(pdf_path)
    if len(txt) >= 400:  # umbral empírico
        return txt

    # 2
    alt = _extract_with_pdfplumber(pdf_path)
    if len(alt) > len(txt):
        txt = alt
    if len(txt) >= 400:
        return txt

    # 3 (solo si lo pides)
    if use_ocr_if_needed:
        ocr = _extract_with_ocr(pdf_path)
        if len(ocr) > len(txt):
            txt = ocr

    return txt
