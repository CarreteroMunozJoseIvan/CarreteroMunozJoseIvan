def parse_account_name(text: str):
    """
    Account Name:
    - Buscar TODAS las apariciones de 'ORIGINAL INSURED'
    - Usar SIEMPRE la ÚLTIMA (la de abajo)
    - Dentro de ese bloque, buscar 'Name:' y coger la primera línea no vacía
      después de 'Name:'
    - Si no hubiera 'ORIGINAL INSURED', usamos un fallback genérico.
    """

    lines = text.splitlines()

    # 1) Localizar TODAS las líneas con 'ORIGINAL INSURED'
    indices = [
        i for i, line in enumerate(lines)
        if re.search(r"\bORIGINAL\s+INSURED\b", line, flags=re.I)
    ]

    if indices:
        # 2) Usamos la ÚLTIMA aparición
        start_idx = indices[-1]

        # 3) Buscar 'Name:' en las siguientes líneas de ese bloque
        name_idx = None
        for j in range(start_idx + 1, min(start_idx + 25, len(lines))):
            if re.search(r"\bName\b\s*:", lines[j], flags=re.I):
                name_idx = j
                break

        # 4) La primera línea NO vacía tras 'Name:' es el Account Name
        if name_idx is not None:
            for k in range(name_idx + 1, min(name_idx + 10, len(lines))):
                cand = lines[k].strip(" :-;")
                if cand:
                    return cand

        # Fallback por si el nombre estuviera en la misma línea de 'Name:'
        if name_idx is not None:
            m = re.search(r"Name\s*:\s*(.+)", lines[name_idx], flags=re.I)
            if m:
                cand = m.group(1).strip(" :-;")
                if cand:
                    return cand

    # ============== FALLO COMPLETO: NO HAY 'ORIGINAL INSURED' ==============
    # Fallback genérico, intentando NO coger el bloque de REINSURED
    text_no_reinsured = re.sub(
        r"REINSURED.*?Address:",
        " ",
        text,
        flags=re.I | re.S
    )

    t = re.sub(r"[^\S\r\n]+", " ", text_no_reinsured)

    for pat in [r"\bInsured\s*:\s*(.+)", r"\bAssured\s*:\s*(.+)"]:
        m = re.search(pat, t, flags=re.I)
        if m:
            return m.group(1).splitlines()[0].strip(" :-;")

    return None
